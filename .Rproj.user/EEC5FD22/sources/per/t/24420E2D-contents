---
jupyter: 
  jupytext: 
    cell_metadata_filter: -all 
    formats: ipynb,markdown//md 
    main_language: code-cell 
    text_representation: 
      extension: .md 
      format_name: markdown 
      format_version: '1.3' 
      jupytext_version: 1.14.1 
---

# Assignment 4

### Due Monday November 28, 2022 at 11:59pm PT on Gradescope.

## Problem 1

This question relates to the below figure:

![Partition figure](http://web.stanford.edu/class/stats202/_images/fig814.png)

(a) Sketch the tree corresponding to the partition of the predictor space illustrated in the left-hand panel of the figure. The numbers inside the boxes indicate the mean of $Y$ within each region.

(b) Create a diagram similar to the left-hand panel of the figure, using the tree illustrated in the right-hand panel of the same figure. You should divide up the predictor space into the correct regions, and indicate the mean for each region.

## Problem 2

In the lab, we applied random forests to the `Boston` data using `mtry = 6` and using `ntree = 25` and `ntree = 500`. Create a plot displaying the test error resulting from random forests on this data set for a more comprehensive range of values for mtry and ntree. You can model your plot after Figure 8.10 in the book. Describe the results obtained.
```{r}
# install.packages("randomforest")
library(randomForest)
# install.packages("tree")
library(tree)
library(MASS)
library(ggplot2)
library(dplyr)
```


```{r}

train <- sample(1:nrow(Boston), nrow(Boston) / 2)
train.fixed <- train

get_test_error <- function(m_try, n_tree) {
  
  boston.test <- Boston[-train, "medv"]
  bag.boston <- randomForest(medv ~ ., data = Boston, 
                             subset = train.fixed, mtry = m_try, ntree = n_tree)
  yhat.bag <- predict(bag.boston, newdata = Boston[-train.fixed, ])
  return (mean((yhat.bag - boston.test)^2))
}

set.seed(1)

p <- ncol(Boston)
n_tree <- seq(1, 250, by=5)
m_try <- seq(1, p, by=2)

combo <- data.frame(tidyr::crossing(m_try, n_tree))

test_errors <- mapply(get_test_error, combo$m_try, combo$n_tree)

combo <- data.frame(cbind(combo, test_errors))

combo %>%
  ggplot(aes(x = n_tree, y = test_errors, group = m_try, color = m_try)) + 
  geom_line()



```
Test Error  was significantly lower after performing random_forest with more than 1 variable and about 20 trees. After that, test error didn't vary too much.


## Problem 3

We now use boosting to predict `Salary` in the `Hitters` data set.

(a) Remove the observations for whom the salary information is unknown, and then log-transform the salaries.
```{r}
library(ISLR2)
library(gbm)
library(ggplot2)

clean_hit <- Hitters %>%
  na.omit() %>%
  mutate(LogSalary = log(Salary)) %>%
  select(-Salary)


```


(b) Create a training set consisting of the first 200 observations, and a test set consisting of the remaining observations.
```{r}

train <- clean_hit[1:200,]
test <- clean_hit[201: nrow(clean_hit) , ]

```

(c) Perform boosting on the training set with 1,000 trees for a range of values of the step size $\lambda$. Produce a plot with different shrinkage values on the x-axis and the corresponding training set MSE on the y-axis.

```{r}
set.seed(1)
lambda = seq(from=0, to=1,by=0.02)
train_errors_3_c = list()

for (lam in lambda) {
  boost.hitters <- gbm(LogSalary ~ ., data = train, distribution = "gaussian", n.trees = 1000, interaction.depth = 4, shrinkage = lam)
  yhat.boost <- predict(boost.hitters, newdata = train, n.trees = 1000)
  train_errors_3_c <- append(train_errors_3_c, (mean((yhat.boost - train$LogSalary)^2)))
}
train_errors_3_c <- unlist(train_errors_3_c)

error_and_lambda <- as.data.frame(cbind(lambda, train_errors_3_c))

ggplot(data=error_and_lambda, aes(x=lambda, y=train_errors_3_c)) + 
  ggtitle("Training Error and Shrinkage") +
  geom_line() +
  geom_point()

```

(d) Produce a plot with different shrinkage values on the x-axis and the corresponding test set MSE on the y-axis.
```{r}

lambda = seq(from=0, to=1,by=0.02)
test_errors_3_c = list()

for (lam in lambda) {
  boost.hitters <- gbm(LogSalary ~ ., data = train, distribution = "gaussian", n.trees = 1000, interaction.depth = 4, shrinkage =  lam)
  yhat.boost <- predict(boost.hitters, newdata = test, n.trees = 1000)
  test_errors_3_c <- append(test_errors_3_c, (mean((yhat.boost - test$LogSalary)^2)))
}
test_errors_3_c <- unlist(test_errors_3_c)

error_and_lambda <- as.data.frame(cbind(lambda, test_errors_3_c))

ggplot(data=error_and_lambda, aes(x=lambda, y=test_errors_3_c)) + 
  ggtitle("Test Error and Shrinkage") +
  geom_line() +
  geom_point()

```

(e) Compare the test MSE of boosting to the test MSE that results from applying random forests and from applying one of the regression approaches seen in Chapters 3 and 6.
```{r}

# Find boosted model with lowest test error
bst.error <- min(test_errors_3_c)

# Perform random forest
library(randomForest)
# generally m = sqrt(p), we'll go ahead and do that 
m = round(sqrt(ncol(train) - 1))
rf.logsalary <- randomForest(LogSalary ~ ., data = train, mtry = m, importance = TRUE)
yhat.rf <- predict(rf.logsalary, newdata = test)
rf.error <- mean((yhat.rf - test$LogSalary)^2)

# Perform linear regression
ln.logsalary <- lm(LogSalary ~ ., data = train)
yhat.linear <- predict(ln.logsalary, newdata = test)
ln.error <- mean((yhat.linear - test$LogSalary)^2)


bst.error
rf.error
ln.error

```
It appears that the random forest produces the best (lowest) test error across the Boosted trees and Linear models. 

(f) Which variables appear to be the most important predictors in the boosted model?
```{r}
# We will select the boosted model with the lambda that results in the lowest test score
minlam = error_and_lambda[which.min(error_and_lambda$test_errors_3_c), lambda]

best.boost.hitters <- gbm(LogSalary ~ ., data = train, distribution = "gaussian", n.trees = 1000, interaction.depth = 4, shrinkage =  minlam)


summary(best.boost.hitters)


```
The most important variables are CAtBat & CWalks.

(g) Now apply bagging to the training set. What is the test set MSE for this approach?
```{r}

set.seed(1)
bag.hitters <- randomForest(LogSalary ~ ., data = train, mtry = ncol(train) - 1, importance = TRUE)
bag.hitters

yhat.bag <- predict(bag.hitters, newdata = test)

mean((yhat.bag - test$LogSalary)^2)

```


## Problem 4

Apply boosting, bagging, random forests, and BART to a data set of your choice. Be sure to fit the models on a training set and to evaluate their performance on a test set. How accurate are the results compared to simple methods like linear or logistic regression? Which of these approaches yields the best performance?
```{r}
set.seed(19)
data(Wage)
mses <- c()

# Make a training and test dataset
clean_wage <- Wage %>% na.omit() %>% select(-logwage, -region)
sample <- sample(c(TRUE, FALSE), nrow(clean_wage), replace=TRUE, prob=c(0.7,0.3))
train.wage  <- clean_wage[sample, ]
test.wage   <- clean_wage[!sample, ]

## Perform Boosting
boost.wage <- gbm(wage ~ ., data = train.wage, distribution = "gaussian", n.trees = 5000, interaction.depth = 4)
boost.y.hat <- predict(boost.wage, newdata = test.wage)
mses["boost"] <- mean((boost.y.hat - test.wage$wage)^2)

## Perform Random Forest 
m = round(ncol(train.wage) - 1) # pick m = sqrt(p)
rf.wage <- randomForest(wage ~ ., data = train.wage, mtry = m, importance = TRUE)
rf.y.hat <- predict(rf.wage, newdata = test.wage)
mses["rf"] <- mean((rf.y.hat - test.wage$wage)^2)

## Perform Bagging
bag.wage <- randomForest(wage ~., data = train.wage, mtry = ncol(train.wage) - 1, importance = TRUE)
bag.y.hat <- predict(bag.wage, newdata = test.wage)
mses["bag"] <- mean((bag.y.hat - test.wage$wage)^2)

## Perform BART
library(BART)
xtrain <- train.wage %>% select(-wage)
ytrain <- train.wage$wage
xtest <- test.wage %>% select(-wage)
ytest <- test.wage$wage

bartfit <- gbart(xtrain, ytrain, x.test = xtest)
yhat.bart <- bartfit$yhat.test.mean
mses["bart"] <- mean((test.wage$wage - yhat.bart)^2)

## Perform Linear
lr.wage <- lm(wage ~ ., data = train.wage )
lr.y.hat <- predict(lr.wage, newdata = test.wage)
mses["linear"] <- mean((lr.y.hat - test.wage$wage)^2)

# Compare all of the test MSE

mses


```
It appears that BART produced the lowest test error, but linear regression was close behind.


## Problem 5

Suppose that we have four observations, for which we compute a dissimilarity matrix, given by

$$ 
\begin{bmatrix} 
 & .6 & .3 & .9 \\ 
 .6 &  & .2 & .35 \\ 
 .3 & .2 &  & .5 \\ 
 .9 & .35 & .5 &  
\end{bmatrix} 
$$

For instance, the dissimilarity between the first and second observations is 0.6, and the dissimilarity between the second and fourth observations is 0.35.

(a) On the basis of this dissimilarity matrix, sketch the dendrogram that results from hierarchically clustering these four observations using complete linkage. Be sure to indicate on the plot the height at which each fusion occurs, as well as the observations corresponding to each leaf in the dendrogram.

(b) Repeat (a), this time using single linkage clustering.

(c) Suppose that we cut the dendrogram obtained in (a) such that two clusters result. Which observations are in each cluster?

(d) Suppose that we cut the dendrogram obtained in (b) such that two clusters result. Which observations are in each cluster?

(e) It is mentioned in the chapter that at each fusion in the dendrogram, the position of the two clusters being fused can be swapped without changing the meaning of the dendrogram. Draw a dendrogram that is equivalent to the dendrogram in (a), for which two or more of the leaves are repositioned, but for which the meaning of the dendrogram is the same.

## Problem 6

In this problem, you will perform $K$-means clustering manually, with `K = 2`, on a small example with `n = 6` observations and `p = 2` features. The observations are as follows.

| Obs | X_1 | X_2 |
|:---:|:---:|:---:|
|  1  |  2  |  5  |
|  2  |  0  |  3  |
|  3  |  1  |  6  |
|  4  |  4  |  2  |
|  5  |  1  |  4  |
|  6  |  5  |  2  |

(a) Plot the observations.

(b) Randomly assign a cluster label to each observation. You can use the `sample()` command in R to do this. Report the cluster labels for each observation.

(c) Compute the centroid for each cluster.

(d) Assign each observation to the centroid to which it is closest, in terms of Euclidean distance. Report the cluster labels for each observation.

(e) Repeat (c) and (d) until the answers obtained stop changing.

(f) In your plot from (a), color the observations according to the cluster labels obtained.

## Problem 7

In Section 12.2.3, a formula for calculating PVE was given in Equation 12.10. We also saw that the PVE can be obtained using the `sdev` output of the `prcomp()` function. You will simulate data, and calculate PVE in two ways.

To simulate data, create random normal data matrix of 50 observations and 4 variables using `rnorm()`. For grading purposes, please set the random seed to 1 (`set.seed(1)`).

(a) Using the `sdev` output of the `prcomp()` function, as was done in Section 12.2.3.

(b) By applying Equation 12.10 directly. That is, use the `prcomp()` function to compute the principal component loadings. Then, use those loadings in Equation 12.10 to obtain the PVE. These two approaches should give the same results.

*Hint: You will only obtain the same results in (a) and (b) if the same data is used in both cases. For instance, if in (a) you performed `prcomp()` using centered and scaled variables, then you must center and scale the variables before applying Equation 12.10 in (b).*

## Problem 8

In this problem, you will generate simulated data, and then perform PCA and K-means clustering on the data.

(a) Generate a simulated data set with 25 observations in each of four classes (i.e. 100 observations total), and 50 variables.

*Hint: There are a number of functions in R that you can use to generate data. One example is the rnorm() function; runif() is another option. Be sure to add a mean shift to the observations in each class so that there are three distinct classes.*

(b) Perform PCA on the 100 observations and plot the first two principal component score vectors. Use a different color to indicate the observations in each of the three classes. If the four classes appear separated in this plot, then continue on to part (c). If not, then return to part (a) and modify the simulation so that there is greater separation between the four classes. Do not continue to part (c) until the four classes show at least some separation in the first two principal component score vectors.

(c) Perform K-means clustering of the observations with `K = 4`. How well do the clusters that you obtained in K-means clustering compare to the true class labels? Hint: You can use the `table()` function in R to compare the true class labels to the class labels obtained by clustering. Be careful how you interpret the results: K-means clustering will arbitrarily number the clusters, so you cannot simply check whether the true class labels and clustering labels are the same.

(d) Perform K-means clustering with `K = 3`. Describe your results.

(e) Now perform K-means clustering with `K = 5`, and describe your results.

(f) Now perform K-means clustering with `K = 4` on the first two principal component score vectors, rather than on the raw data. That is, perform K-means clustering on the 100x2 matrix of which the first column is the first principal component score vector, and the second column is the second principal component score vector. Comment on the results.

(g) Using the `scale()` function, perform K-means clustering with `K = 4` on the data after scaling each variable to have standard deviation one. How do these results compare to those obtained in (b)? Explain.
